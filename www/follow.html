<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!--    Include the purecss.io CSS files for formatting and responsive design-->
    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css"
          integrity="sha384-4ZPLezkTZTsojWFhpdFembdzFudphhoOzIunR1wH6g1WQDzCAiPvDyitaK67mp0+" crossorigin="anonymous">
    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/base-min.css">
    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-min.css">
    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">
    <!--    Make sure the width is equal to the device's native width-->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="./styles.css" rel="stylesheet" type="text/css"/>

    <!--    Get D3 for plotting-->
    <script src="https://d3js.org/d3.v4.js"></script>

    <!--    Get jQuery-->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>

    <title>Genghis</title>
</head>
<body>
<!--Genghis Header-->
<div class="pure-g">
    <div class="pure-u-1-1">
        <div style="display:flex">
            <div>
                <a class="silent" href="../index.html">
                    <h1>Genghis</h1>
                    <h4>Bot Battle System</h4>
                </a>
            </div>
            <div id="header-info">
                <label for="cmb_game">Game:</label>
                <select name="game" id="cmb_game">
                </select>
                <br>
                <br>
                <label for="cmb_following">Following:</label>
                <select name="following" id="cmb_following">
                </select>
            </div>
        </div>
    </div>
</div>
<!--Battleground Card-->
<div class="pure-g" id="bg_card">
    <div class="pure-u-1-1">
        <div class="shadow">
            <p style="color: lightgray">1 2 3 4 A B C D E F G H</p>
            <h2>Battleground 1</h2>
            <!--            Now another group for the BG and it's stats-->
            <div class="pure-g">
                <div class="pure-u-md-3-5 pure-u-1-1">
                    <div id="bg_plot">
                        <svg xmlns="http://www.w3.org/2000/svg">
                            <rect width="100%" height="100%" fill="lightgrey"/>
                            <text x="20" y="30">Battleground 1</text>
                        </svg>
                    </div>
                </div>
                <div class="pure-u-md-2-5 pure-u-1-1">
                    <p>Information about that thing you just clicked...</p>
                </div>
            </div>
        </div>
    </div>
</div>
<!--Graph Card: number of coins per bot over time-->
<div class="pure-g" id="cpb_card">
    <div class="pure-u-1-1">
        <div class="shadow">
            <h2>Total coins per Bot</h2>
            <div id="cpb_plot">
                <svg xmlns="http://www.w3.org/2000/svg" height="300px">
                    <rect width="100%" height="100%" fill="lightgrey"/>
                    <text x="20" y="30">Total coins per Bot</text>
                </svg>
            </div>
        </div>
    </div>
</div>
<!--Graph Card: number of bots per battleground over time-->
<div class="pure-g" id="bot_locs_card">
    <div class="pure-u-1-1">
        <div class="shadow">
            <h2>Bot Locations</h2>
            <div id="bot_locs_plot">
                <svg xmlns="http://www.w3.org/2000/svg" height="300px">
                    <rect width="100%" height="100%" fill="lightgrey"/>
                    <text x="20" y="30">Total coins per Bot</text>
                </svg>
            </div>
        </div>
    </div>
</div>
<!--Entity Info Card-->
<!--<div class="pure-g">-->
<!--    <div class="pure-u-1-1">-->
<!--        <div class="shadow">-->
<!--            <h2>Info about Followed Entity</h2>-->
<!--            <pre>-->
<!--{-->
<!--}-->
<!--            </pre>-->
<!--        </div>-->
<!--    </div>-->
<!--</div>-->
<script>
    function get_param(param, defaultvalue) {
        if (window.location.href.indexOf(param) > -1) {
            let vars = {};
            let parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi,
                (m, key, value) => {
                    vars[key] = value;
                });
            return vars[param]
        }
        return defaultvalue;
    }

    function draw_battleground(div_id, bg_port_icon) {
        // Get the bg_map from the text file
        const cell_width = 20;
        const cell_height = 20;
        let selected_game_path = get_param("game", "");
        $.ajax({
            url: "../" + selected_game_path + "/" + bg_port_icon + '.log'
        }).done(bg_map => {
            let map = [];
            bg_map.split('\n').forEach(d => {
                if (d.length > 0) {
                    map.push(d.split(''))
                }
            })

            // set the dimensions and margins of the graph
            const margin = {top: 10, right: 10, bottom: 10, left: 10};
            const width = cell_width * map[0].length;
            const height = cell_height * map.length;

            // append the svg object to the body of the page
            d3.select('#' + div_id).selectAll("svg").remove();
            const svg = d3.select('#' + div_id)
                .append("svg")
                // .attr("width", document.getElementById(div_id).offsetWidth)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            const grid_data = [];
            let xpos = 1;
            let ypos = 1;

            for (let row = 0; row < map.length; row++) {
                grid_data.push([]);
                for (let column = 0; column < map[0].length; column++) {
                    grid_data[row].push({
                        x: xpos,
                        y: ypos,
                        width: cell_width,
                        height: cell_height,
                        content: map[row][column],
                        click: 0,
                    })
                    xpos += cell_width;
                }
                xpos = 1;
                ypos += cell_height;
            }

            let row = svg.selectAll(".row")
                .data(grid_data)
                .enter().append("g")
                .attr("class", "row");
            const COL_HOVER = ["#eee", "#aaa"];
            const COL_NO_HOVER = ["#fff", "#aaa"];
            let square_group = row.selectAll(".square")
                .data(d => d)
                .enter().append("g")
                .attr("class", "square")
                .on('click', function (d) {
                    d.click++;
                    d3.select(this).selectAll('rect').style("fill", COL_NO_HOVER[(d.click) % 2]);
                    // d3.select(this).selectAll('text').style("fill", ((d.click) % 2 === 0) ? "#000000" : "#4f4f4f");
                })
                .on('mouseover', function (d) {
                    d3.select(this).selectAll('rect').style("fill", COL_HOVER[(d.click) % 2]);
                    // d3.select(this).selectAll('text').style("fill", ((d.click) % 2 === 0) ? "#000000" : "#1d1d1d");
                })
                .on('mouseout', function (d) {
                    d3.select(this).selectAll('rect').style("fill", COL_NO_HOVER[(d.click) % 2]);
                    // d3.select(this).selectAll('rect').style("fill", ((d.click) % 2 === 0) ? "#ff0000" : "#c2d000");
                    // d3.select(this).selectAll('text').style("fill", ((d.click) % 2 === 0) ? "#000000" : "#000000");
                })
            ;
            let square = svg.selectAll('.square')
                .append("rect")
                .attr("x", d => d.x)
                .attr("y", d => d.y)
                .attr("width", d => d.width)
                .attr("height", d => d.height)
                .style("fill", d => ((d.click) % 2 === 0) ? "#ffffff" : "#a5a5a5")
                .style("stroke", "#222");

            let text = svg.selectAll('.square')
                .append("text")
                .attr("text-anchor", 'middle')
                .attr("alignment-baseline", 'middle')
                // .style("fill", d => ((d.click) % 2 === 0) ? "#a5a5a5" : "#ffffff")
                .attr("x", d => d.x + 0.5 * d.width)
                .attr("y", d => d.y + 0.5 * d.height)
                .text(d => d.content);
        });

    }

    function draw_coins_per_bot(div_id) {
        let selected_game_path = get_param("game", "");

        $.ajax({
            url: "../" + selected_game_path + "/bot_info.json"
        }).done(bot_info => {
            let COLOURS = ["#c4ad3a",
                "#715fcd",
                "#73b638",
                "#c24cb5",
                "#4fbd6a",
                "#da4478",
                "#55b48f",
                "#d04934",
                "#49b9d3",
                "#d9842d",
                "#6380c5",
                "#687428",
                "#be86dd",
                "#3d7d3e",
                "#d983b3",
                "#a3b165",
                "#97487a",
                "#97692f",
                "#b35355",
                "#e29371"]
            const MAX_HISTORY = 2000; // Only show ticks upto MAX_HISTORY ticks in the past
            let unique_bots = [];
            let bots = [];
            for (let i = 0; i < bot_info.length; i++) {
                if (!unique_bots.includes(bot_info[i]['bot_icon'])) {
                    unique_bots.push(bot_info[i]['bot_icon']);
                    bots.push([]);
                }
            }

            unique_bots.sort((a, b) => (a < b) ? -1 : 1);
            const present = d3.max(bot_info, (d) => d.tick);
            // Restructure the data. Each element in data corrosponds to a different bot's data
            for (let i = 0; i < bot_info.length; i++) {
                if (bot_info[i].tick >= present - MAX_HISTORY) {
                    bots[unique_bots.indexOf(bot_info[i].bot_icon)].push(bot_info[i]);
                }
            }

            // set the dimensions and margins of the graph
            const margin = {top: 10, right: 70, bottom: 50, left: 40};
            const width = document.getElementById(div_id).offsetWidth - margin.left - margin.right
            const height = 400 - margin.top - margin.bottom

            d3.select('#' + div_id).selectAll("svg").remove();
            // append the svg object to the body of the page
            const svg = d3.select('#' + div_id)
                .append("svg")
                .attr("height", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const xScale = d3.scaleLinear()
                .domain([Math.max(0, present - MAX_HISTORY), present])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain(d3.extent(bot_info, (e) => e.total_coins))
                .range([height, 0]);

            const colour = d3.scaleOrdinal()
                .domain(unique_bots)
                .range(COLOURS.splice(0, unique_bots.length));

            // Filter out all the fractional ticks for total_coins:
            const yAxisTicks = yScale.ticks()
                .filter(tick => Number.isInteger(tick));
            const yAxis = d3.axisLeft(yScale)
                .tickValues(yAxisTicks)
                .tickFormat(d3.format('d'));

            const line = d3.line()
                .x(d => xScale(d.tick))
                .y(d => yScale(d.total_coins));

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))
                .append("text")
                .attr("y", '2.5em')
                .attr("x", 0)
                .style("text-anchor", "start")
                .style("alignment-baseline", "bottom")
                .text("Game tick");

            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", '-1.5em')
                .attr("x", 0)
                .style("text-anchor", "end")
                .text("Number of coins");


            let x_offset = 5;
            let y_offset = 0;
            for (let i = 0; i < bots.length; i++) {
                let legend = svg.append('g')
                    .datum(bots[i])
                    .attr('class', 'legend')
                    .on('mouseover', () => { // on mouse in show line, circles and text
                        d3.selectAll("path.line").style("opacity", d => d[0].bot_icon === bots[i][0].bot_icon ? 1.0 : 0.3);
                    })
                    .on('mouseout', () => { // on mouse out hide line, circles and text
                        d3.selectAll("path.line").style("opacity", 0.9);
                    });
                if (y_offset > height) {
                    x_offset += 30;
                    y_offset = 0;
                }

                legend.append('rect')
                    .attr('x', width + x_offset)
                    .attr('y', (d, _) => y_offset)
                    .attr('width', 10)
                    .attr('height', 10)
                    .style('fill', d => colour(d[0].bot_icon));
                legend.append('text')
                    .attr("alignment-baseline", 'middle')
                    .attr('x', width + 12 + x_offset)
                    .attr('y', (d, _) => (y_offset) + 7)
                    .text(d => d[0].bot_icon);
                y_offset += 20
                svg.append("path")
                    .datum(bots[i])
                    .attr("class", "line")
                    .style("opacity", "0.9")
                    .style("stroke", d => colour(d[0].bot_icon))
                    .attr("d", line)
                    .on('mouseover', () => { // on mouse in show line, circles and text
                        d3.selectAll("path.line").style("opacity", d => d[0].bot_icon === bots[i][0].bot_icon ? 1.0 : 0.3);
                    })
                    .on('mouseout', () => { // on mouse out hide line, circles and text
                        d3.selectAll("path.line").style("opacity", "0.9");
                    });

            }
        });
    }

    function draw_bot_locs(div_id) {
        let selected_game_path = get_param("game", "");
        $.ajax({
            url: "../" + selected_game_path + "/bot_info.json"
        }).done(bot_info => {
            const MAX_HISTORY = 2000; // Only show ticks upto 300 ticks in the past
            let COLOURS = ["#c4ad3a",
                "#715fcd",
                "#73b638",
                "#c24cb5",
                "#4fbd6a",
                "#da4478",
                "#55b48f",
                "#d04934",
                "#49b9d3",
                "#d9842d",
                "#6380c5",
                "#687428",
                "#be86dd",
                "#3d7d3e",
                "#d983b3",
                "#a3b165",
                "#97487a",
                "#97692f",
                "#b35355",
                "#e29371"]
            let unique_bots = [];
            let unique_battlegrounds = [];
            let bots = [];
            for (let i = 0; i < bot_info.length; i++) {
                if (!unique_bots.includes(bot_info[i]['bot_icon'])) {
                    unique_bots.push(bot_info[i]['bot_icon']);
                    bots.push([]);
                }
                if (!unique_battlegrounds.includes(bot_info[i]['bg_port_icon'].toString())) {
                    unique_battlegrounds.push(bot_info[i]['bg_port_icon'].toString());
                }
            }
            unique_bots.sort((a, b) => (a < b) ? -1 : 1);
            unique_battlegrounds.sort((a, b) => (a < b) ? -1 : 1);
            const present = d3.max(bot_info, (d) => d.tick);
            // Restructure the data. Each element in data corrosponds to a different bot's data
            for (let i = 0; i < bot_info.length; i++) {
                if (bot_info[i].tick >= present - MAX_HISTORY) {
                    bots[unique_bots.indexOf(bot_info[i].bot_icon)].push(bot_info[i]);
                }
            }

            // set the dimensions and margins of the graph
            const margin = {top: 10, right: 70, bottom: 50, left: 40};
            const width = document.getElementById(div_id).offsetWidth - margin.left - margin.right
            const height = 400 - margin.top - margin.bottom
            d3.select('#' + div_id).selectAll("svg").remove();
            // append the svg object to the body of the page
            const svg = d3.select('#' + div_id)
                .append("svg")
                .attr("height", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


            const xScale = d3.scaleLinear()
                .domain([Math.max(0, present - MAX_HISTORY), present])
                .range([0, width]);

            const yScale0 = d3.scaleBand()
                .domain(unique_battlegrounds)
                .rangeRound([height, 0])
                .paddingInner(0.5);

            // const yScale1 = d3.scaleBand()
            const yScale1 = d3.scaleBand()
                .domain(unique_bots)
                .rangeRound([0, yScale0.bandwidth()])
            // .paddingInner(0.25)
            // .domain(d3.extent(bot_info, (e) => e.total_coins))
            // .range([height, 0]);

            const colour = d3.scaleOrdinal()
                .domain(unique_bots)
                .range(COLOURS.splice(0, unique_bots.length));

            // // Filter out all the fractional ticks for total_coins:
            // const yAxisTicks = yScale.ticks()
            //     .filter(tick => Number.isInteger(tick));
            // const yAxis = d3.axisLeft(yScale)
            //     .tickValues(yAxisTicks)
            //     .tickFormat(d3.format('d'));

            const line = d3.line()
                .x(d => xScale(d.tick))
                .y(d => yScale0(d.bg_port_icon) + yScale1(d.bot_icon));

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))
                .append("text")
                .attr("y", '2.5em')
                .attr("x", 0)
                .style("text-anchor", "start")
                .style("alignment-baseline", "bottom")
                .text("Game tick");

            let yAxis = d3.axisLeft(yScale0).tickSize(0);
            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", '-1.5em')
                .attr("x", -height * 0.5)
                .style("text-anchor", "middle")
                // .style("alignment-baseline", "bottom")
                .text("Battleground");


            let x_offset = 5;
            let y_offset = 0;
            for (let i = 0; i < bots.length; i++) {
                let legend = svg.append('g')
                    .datum(bots[i])
                    .attr('class', 'legend')
                    .on('mouseover', () => { // on mouse in show line, circles and text
                        d3.selectAll("path.line").style("opacity", d => d[0].bot_icon === bots[i][0].bot_icon ? 1.0 : 0.3);
                    })
                    .on('mouseout', () => { // on mouse out hide line, circles and text
                        d3.selectAll("path.line").style("opacity", "1");
                    });
                if (y_offset > height) {
                    x_offset += 30;
                    y_offset = 0;
                }
                legend.append('rect')
                    .attr('x', width + x_offset)
                    .attr('y', (d, _) => y_offset)
                    .attr('width', 10)
                    .attr('height', 10)
                    .style('fill', d => colour(d[0].bot_icon));
                legend.append('text')
                    .attr("alignment-baseline", 'middle')
                    .attr('x', width + 12 + x_offset)
                    .attr('y', (d, _) => (y_offset) + 7)
                    .text(d => d[0].bot_icon);
                y_offset += 20

                svg.append("path")
                    .datum(bots[i])
                    .attr("class", "line")
                    .style("stroke", d => colour(d[0].bot_icon))
                    .attr("d", line)
                    .on('mouseover', () => { // on mouse in show line, circles and text
                        d3.selectAll("path.line").style("opacity", d => d[0].bot_icon === bots[i][0].bot_icon ? 1.0 : 0.3);
                    })
                    .on('mouseout', () => { // on mouse out hide line, circles and text
                        d3.selectAll("path.line").style("opacity", "1");
                    });

            }
        });
    }

    function update_following() {
        let cmb_following = document.getElementById("cmb_following");
        let cmb_game = document.getElementById("cmb_game");
        let forwarding_url;
        if (cmb_game.value !== 'Overview') {
            forwarding_url = 'follow.html?game=' + cmb_game.value;
            if (cmb_following.value !== 'Overview') {
                forwarding_url += '&following=' + cmb_following.value;
            }
        } else {
            forwarding_url = '../index.html';
        }
        window.location.href = forwarding_url;
    }

    // Update the list of running games
    $.ajax({
        url: "../server_state.json"
    }).done(data => {
        if (data && data['games']) {
            // Populate the list of games available
            let games_list = ["Overview"];
            data['games'].forEach((game) => {
                games_list.push(game['game_dir']);
            });
            let cmb_game = document.getElementById("cmb_game");
            cmb_game.setAttribute("onchange", "update_following()")
            cmb_game.innerHTML = "";

            let game_is_selected = false;
            for (let i = 0; i < games_list.length; i++) {
                let option = document.createElement("option");
                option.value = games_list[i];
                option.text = games_list[i];
                if (get_param("game", "") === games_list[i]) {
                    option.setAttribute("selected", "selected")
                    game_is_selected = true
                }
                cmb_game.appendChild(option);
            }
            if (!game_is_selected) {
                window.location.href = '../index.html';
            }
        }
    });

    let selected_game_path = get_param("game", "");
    $.ajax({
        url: "../" + selected_game_path + "/game.json"
    }).done(game => {
        let following_list = ["Overview"];
        game['bots'].sort((a, b) => a['bot_icon'] > b['bot_icon'] ? 1 : -1);
        game['bots'].forEach((bot) => {
            following_list.push(bot['bot_icon']);
        });

        game['battlegrounds'].sort((a, b) => a['port_icon'] < b['port_icon'] ? 1 : -1);
        game['battlegrounds'].forEach((bg) => {
            following_list.push(bg['port_icon']);
        });

        let cmb_following = document.getElementById("cmb_following");
        cmb_following.setAttribute("onchange", "update_following()");
        cmb_following.innerHTML = "";
        for (let i = 0; i < following_list.length; i++) {
            let option = document.createElement("option");
            option.value = following_list[i];

            if (i !== 0) {
                if (i - 1 < game['bots'].length) {
                    option.text = "Bot " + following_list[i];
                } else {
                    option.text = "Battleground " + following_list[i];
                }
            } else {
                option.text = following_list[i];
            }
            if (get_param("following", "") === following_list[i]) {
                option.setAttribute("selected", "selected")
            }
            cmb_following.appendChild(option);
        }
    });

    // Now start doing the draw loop
    $.ajaxSetup({cache: false});
    const interval = 1000;

    function loop() {
        let following = get_param('following', '');
        if (following !== '') {
            if (!isNaN(following)) {
                draw_battleground("bg_plot", following)
                document.getElementById('cpb_card').remove();
                document.getElementById('bot_locs_card').remove();
            } else { // Following is a bot_icon, so find it and plot it

            }
        } else {
            document.getElementById('bg_card').remove();
            draw_coins_per_bot("cpb_plot")
            draw_bot_locs("bot_locs_plot")
        }
        setTimeout(loop, interval);
    }

    setTimeout(loop, interval);
</script>

</body>
</html>
